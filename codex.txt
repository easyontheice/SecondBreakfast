You are Codex in Agent mode, acting as a senior full-stack engineer. Build a cross-platform desktop app with a modern “badass” GUI: Tauri v2 (Rust backend) + React + Tailwind + shadcn/ui.

# 0) Non-negotiable Product Contract
This app is a DROP-ZONE SORTER. The user chooses a “Sort Folder” (aka sortRoot). The app watches sortRoot and auto-sorts everything dropped into it into category subfolders INSIDE sortRoot. This must work for both file drops and folder drops.

IMPORTANT: sortRoot is NOT hardcoded. Provide a default suggestion (e.g., Windows: C:\Users\<user>\Sort), but require the user can pick/change it in-app at any time.

# 1) Primary workflow
- User selects sortRoot in onboarding (folder picker).
- App ensures category subfolders exist under sortRoot:
  Documents, Images, Video, Audio, Archives, Code, Executables, Data, Misc
- User drags/drops files and/or folders into sortRoot using the OS file explorer.
- App watches sortRoot. On change: debounce, then process.

# 2) Sorting Behavior (Flatten Mode)
- Flatten mode (mandatory for MVP): do NOT preserve source folder structure inside categories.
  Example: sortRoot\SomeDump\A\B\song.mp3 -> sortRoot\Audio\song.mp3
- Classification by extension:
  Documents: doc docx rtf txt md pdf odt xls xlsx ods csv ppt pptx epub
  Images: jpg jpeg png gif bmp webp tif tiff svg ico psd
  Video: mp4 mkv mov avi wmv webm m4v
  Audio: mp3 wav flac aac m4a ogg
  Archives: zip rar 7z tar gz tgz bz2 iso
  Code: py js ts html htm css c cpp h hpp cs java sh bat ps1 json yaml yml xml
  Executables: exe msi deb rpm app apk jar
  Data: db sqlite sql parquet
  Unknown extension -> Misc
  No-extension -> Misc (default)
- Collision policy: rename (file.ext -> file (1).ext -> file (2).ext)
- Safety: only move files older than minFileAgeSeconds (default 10s) to avoid partial downloads.

# 3) Folder Cleanup (Trash/Recycle, never permanent by default)
After a run:
- Delete empty folders inside sortRoot that remain from the user’s dropped trees.
- NEVER delete:
  - sortRoot itself
  - category folders (Documents/Images/Video/Audio/Archives/Code/Executables/Data/Misc)
- Cleanup is bottom-up (post-order).
- Deletion mode: send to Trash/Recycle Bin (NOT permanent).
- Respect minDirAgeSeconds (default 60s) to avoid racing ongoing moves.

# 4) UI Requirements (Modern badass, not cluttered)
Use dark theme + crisp spacing + shadcn/ui.
Screens:
A) Onboarding (first run or if sortRoot missing)
   - Folder picker: “Choose your Sort Folder”
   - Shows what will be created (category subfolders)
   - Button: “Start Watching”
B) Dashboard
   - Status: Watching <sortRoot>
   - Buttons: Run Now, Dry Run, Pause/Resume Watcher
   - Live Activity Feed: moved file -> destination, errors, cleanup events
   - Run summary: moved/skipped/errors
C) Rules
   - Category cards with editable extension chips
   - Toggle: Unknown -> Misc, No-ext -> Misc
   - Collision policy dropdown
   - File age slider (minFileAgeSeconds)
D) Cleanup
   - Toggle cleanup
   - Dir age slider (minDirAgeSeconds)
   - Trash mode indicator
E) Settings
   - “Change Sort Folder” (folder picker)
   - Protected folders display
   - Export/Import rules.json

# 5) Config + Persistence
Store config in OS app config directory.
Config file: rules.json with schema:
- global: sortRoot, caseInsensitiveExt, collisionPolicy, unknownGoesToMisc, noExtensionGoesToMisc, minFileAgeSeconds, cleanupEmptyFolders{enabled,minAgeSeconds,mode:"trash"}
- categories: id, name, targetSubfolder, extensions[]
- misc: name, targetSubfolder
Provide a sensible default config but require UI can change sortRoot and persist it.

# 6) Engineering Requirements (Rust backend)
Use simple, stable crates:
- notify for filesystem watching
- walkdir for bottom-up traversal
- trash for cross-platform recycle/trash
Implement core modules:
- rules.rs (load/save/validate + build extension lookup map)
- planner.rs (scan + build plan, supports dry-run)
- executor.rs (execute plan: move files, rename collisions; emit progress events)
- cleanup.rs (bottom-up empty folder trash; protected set)
- watcher.rs (notify + debounce -> run pipeline)
- journal.rs (append-only JSONL for MVP + undo-last-run)
- errors.rs (centralized error types)

Undo-last-run:
- Record each move: timestamp, src, dest
- Undo = best effort: move back if source path free; otherwise skip with report.

# 7) Tauri Command API + Events (UI ↔ backend contract)
Commands:
- get_rules() -> Rules
- set_rules(Rules) -> ()
- validate_rules(Rules) -> ValidationResult
- set_sort_root(path: string) -> ()
- dry_run() -> PlanPreview
- run_now() -> RunResult
- undo_last_run() -> UndoResult
- start_watcher() / stop_watcher() / watcher_status()

Events emitted during run:
- run_progress { moved, skipped, errors, currentPath, destPath }
- run_log { level: "info"|"warn"|"error", message }
- watcher_status { running, sortRoot }

# 8) Repo Structure
Create:
- docs/SPEC.md (behavior, edge cases, acceptance tests)
- src-tauri/src: main.rs + modules listed above
- src/: React UI with routes/components

# 9) Work Plan (commit-by-commit, keep it shippable)
1) Scaffold Tauri v2 + React + Tailwind + shadcn/ui. Dev run works.
2) Implement config/rules load/save + onboarding sortRoot picker. Create category dirs.
3) Implement planner + Dry Run preview UI grouped by category.
4) Implement executor + progress feed. Verify rename-on-collision.
5) Implement cleanup to Trash + protected dirs hard guarantee.
6) Implement watcher + debounce + pause/resume.
7) Implement journal + undo-last-run UI.
8) Build installers + write README build/run instructions for Windows + Ubuntu.

# 10) Acceptance Tests (must pass)
- User can choose sortRoot in UI; app persists it; can change it later.
- Dropping mixed folder tree into sortRoot results in correct categorization and flattened destinations.
- Unknown ext -> Misc; no ext -> Misc.
- Category dirs never deleted. sortRoot never deleted.
- Empty remnants are trashed after run.
- Dry run matches run results (counts and destinations).
- Undo-last-run restores moved files best-effort; reports conflicts/skips.

# Codex Operating Instructions
- Ask at most 3 questions only if truly blocking; otherwise choose sensible defaults.
- Run the app after each milestone (dev build) and fix errors immediately.
- Keep changes reviewable; summarize after each milestone with next steps.

Blocking questions (only ask if needed):
1) Confirm default suggested sortRoot path pattern per OS is acceptable (but user can pick anything).
2) Confirm category folder names (Documents, Images, Video, Audio, Archives, Code, Executables, Data, Misc).
3) Confirm watcher debounce default = 2 seconds.

Now begin by scaffolding the repo and writing docs/SPEC.md, then implement step 1.

--------

POLISH PASS AFTER BUILDING APP AND ENSURING FUNCTIONALITY


You are Codex in Agent mode. Perform a dedicated UI/UX polish pass on the existing Folder Goblin Tauri v2 + React app. The backend logic already works; your job is to make the GUI feel modern, premium, and fast—without clutter.

## Goals
- “Modern badass” aesthetic: dark mode, crisp typography, confident spacing, subtle motion.
- Improve readability and hierarchy: dashboard first, rules second, settings last.
- Make the activity feed feel alive: clear status, progress, and errors.
- Maintain simplicity: do NOT add power-user complexity that distracts from the drop-zone workflow.

## Non-negotiables
- Keep existing functionality intact.
- Don’t break build. Run and verify after changes.
- No heavy dependencies beyond the current stack (React + Tailwind + shadcn/ui + lucide-react is fine).
- Ensure keyboard accessibility and sane focus states.

## Visual Style System
- Use Tailwind and shadcn/ui tokens consistently.
- Dark theme default with high contrast for text, muted surfaces, subtle borders.
- Use a single accent color for primary actions (don’t rainbow).
- Rounded corners (2xl), soft shadows, subtle gradients allowed but restrained.
- Motion: Framer Motion is allowed if not already present; keep animations subtle (150–250ms).

## Layout
### App Shell
- Left sidebar navigation: Dashboard, Rules, Cleanup, Settings.
- Main content area with max width, good padding, responsive layout.
- Top bar: app title + watcher status pill + Run Now/Dry Run buttons.

### Dashboard
- Hero card: “Watching: <sortRoot>” with “Change” link.
- Primary actions: Run Now, Dry Run, Pause/Resume (prominent).
- Stats row: moved / skipped / errors / last run time.
- Activity feed:
  - Group by run session
  - Each row shows: icon + source filename + destination category + timestamp
  - Error rows are clearly distinguished, include an expandable details drawer.

### Rules Screen
- Category cards in a responsive grid.
- Each card includes:
  - Category name
  - Extension chips (editable)
  - “Add extension” inline input
  - Count of extensions
- Sticky footer bar: Save / Revert / Export / Import

### Cleanup Screen
- Simple toggles and sliders:
  - Cleanup enabled
  - Folder min age (seconds/minutes)
  - Trash mode indicator (locked)
- Explain in plain language what will be deleted (empty remnants only; category folders protected).

### Settings Screen
- Sort Folder picker (Change sortRoot)
- Toggles: no-ext -> misc, unknown -> misc, collision policy, minFileAgeSeconds
- Protected folders list shown read-only.

## UX Improvements
- Add “Dry Run Preview” modal/page:
  - shows grouped destination buckets with counts
  - shows potential conflicts (renames)
- Toast notifications for:
  - run started, run complete, undo complete, errors
- Loading states:
  - progress bar during run
  - disabled buttons while running
- Make “Undo last run” visible but not scary:
  - place in activity header with confirmation.

## Implementation Instructions
- Use shadcn/ui components (Card, Button, Badge, Tabs, Dialog, Toast/Sonner).
- Use lucide-react icons: Folder, Play, Pause, Undo, Settings, Wrench, Trash2, FileText, Image, Film, Music, Archive, Code, Database, HelpCircle.
- Use a consistent icon mapping per category in UI.
- Provide a clean, maintainable component structure:
  - src/components/shell/AppShell.tsx
  - src/components/dashboard/…
  - src/components/rules/…
  - src/components/common/…

## Verification
- Run the dev server and ensure all routes render.
- Verify a full run still works and progress updates show in UI.
- Verify a dry run preview works.
- Verify changing sortRoot is still functional.

## Output
- Commit changes with message: “UI polish pass: modern badass shell + dashboard + rules cards”.
- Summarize changes and note any follow-ups you’d do if given more time.

Now implement this UI polish pass.

